### Способ измерения

Тестовый стенд - виртуальная машина с 4ГБ памяти и 2 ядрами. Память на хип выделено 1ГБ (-Xms1024m -Xmx1024m)

Запуск тестов осуществляется путем вызова метода run() из класса Benchmark.

Точка входа - класс Misc. В этом же классе организована подписка на GarbageCollectorMXBean с выводом основных показателей на консоль.

Помимо этого, в параметрах запуска указан вывод краткого лога -Xlog:gc на консоль. Плюс вывод детального лога в файл.
Вывод логов и текстовая информация с консоли сохранены в папке logs.

Детальный лог для каждого из рассматриваемых сборщиков мусора обработан в онлайн анализаторе логов [gceasy.io](gceasy.io).

Рассмотрим результаты.

### SerialGC

[gceasy.io log](https://gceasy.io/my-gc-report.jsp?p=c2hhcmVkLzIwMTkvMTEvNS8tLVNlcmlhbEdjLS0yMC01MS0yMA==&channel=WEB)

_1_ Throughput : **85.737%**

_2_ Latency:

|Pause|Duration|
|---|---|
|Avg Pause GC Time| 	1 sec 454 ms|
|Max Pause GC Time| 	1 sec 990 ms|

Несмотря на примитивность, serial GC показал приемлемые результаты.  

### ParallelGC

[gceasy.io log](https://gceasy.io/my-gc-report.jsp?p=c2hhcmVkLzIwMTkvMTEvNS8tLVBhcmFsbGVsR2MtLTIwLTU1LTQ=&channel=WEB)

_1_ Throughput : **87.126%**

_2_ Latency:

|Pause|Duration|
|---|---|
|Avg Pause GC Time| 	1 sec 540 ms|
|Max Pause GC Time| 	4 sec 360 ms|

Parallel GC не смог существенно опередить своего предшественника. Вероятно это связано с тем, что высокие накладные расходы "съели" возможные преимущества параллельного выполнения операций.

Параллельное выполнение оказалось не слишком эффективно в условиях: 

1) небольшого количества доступной памяти, что, учитывая относительно большой размер коллекций, не дало эффективно использовать механизм параллельного доступа к памяти (TLAB);

2) всего двух доступных физических ядер. 

### G1GC

[gceasy.io log](https://gceasy.io/my-gc-report.jsp?p=c2hhcmVkLzIwMTkvMTEvNS8tLUcxR2MtLTIwLTU3LTEy&channel=WEB)

_1_ Throughput : **93.832%**

_2_ Latency:

|Pause|Duration|
|---|---|
|Avg Pause GC Time| 	253 ms|
|Max Pause GC Time| 	3 sec 120 ms|

Неожиданно, победителем и по пропускной способности и по задержкам оказался новый сборщик мусора G1. Я связываю это с более эффективной работой с памятью на рассматриваемых параметрах по сравнению с parallel GC.

### Выводы

Главным выводом из проведенной работы можно считать то, что производительность сборщиков мусора зависит от конкретного аппаратного и программного окружения и особенностей реализации приложения. Для выбора конкретного сборщика, требуется помимо понимания различий, проводить замеры и внимательно отслеживать показатели производительности.   
